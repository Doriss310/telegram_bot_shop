-- Supabase schema for Telegram Shop Bot
-- Run in Supabase SQL editor (service role) before migration

-- Core tables
create table if not exists public.users (
  user_id bigint primary key,
  username text,
  balance bigint default 0,
  balance_usdt numeric default 0,
  language text default 'vi',
  created_at timestamptz
);

create table if not exists public.products (
  id bigint generated by default as identity primary key,
  name text not null,
  price bigint not null,
  price_usdt numeric default 0,
  price_tiers jsonb,
  promo_buy_quantity integer default 0,
  promo_bonus_quantity integer default 0,
  website_name text,
  website_price bigint,
  website_price_tiers jsonb,
  website_promo_buy_quantity integer default 0,
  website_promo_bonus_quantity integer default 0,
  website_banner_url text,
  website_logo_url text,
  website_enabled boolean default true,
  description text,
  format_data text
);

create table if not exists public.format_templates (
  id bigint generated by default as identity primary key,
  name text not null,
  pattern text not null,
  created_at timestamptz default now()
);

create table if not exists public.stock (
  id bigint generated by default as identity primary key,
  product_id bigint references public.products(id) on delete cascade,
  content text not null,
  sold boolean default false
);
create index if not exists stock_product_sold_idx on public.stock (product_id, sold);

create table if not exists public.orders (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(user_id),
  product_id bigint references public.products(id),
  content text,
  price bigint,
  quantity integer default 1,
  order_group text,
  created_at timestamptz
);
create index if not exists orders_user_idx on public.orders (user_id);
create index if not exists orders_product_idx on public.orders (product_id);
create index if not exists orders_created_idx on public.orders (created_at desc);

create table if not exists public.deposits (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(user_id),
  amount bigint,
  code text,
  status text default 'pending',
  created_at timestamptz
);
create index if not exists deposits_status_idx on public.deposits (status);

create table if not exists public.withdrawals (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(user_id),
  amount bigint,
  momo_phone text,
  status text default 'pending',
  created_at timestamptz
);
create index if not exists withdrawals_status_idx on public.withdrawals (status);

create table if not exists public.settings (
  key text primary key,
  value text
);

create table if not exists public.binance_deposits (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(user_id),
  usdt_amount numeric,
  vnd_amount bigint,
  code text,
  screenshot_file_id text,
  status text default 'pending',
  created_at timestamptz
);
create index if not exists binance_deposits_status_idx on public.binance_deposits (status);

create table if not exists public.usdt_withdrawals (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(user_id),
  usdt_amount numeric,
  wallet_address text,
  network text default 'TRC20',
  status text default 'pending',
  created_at timestamptz
);
create index if not exists usdt_withdrawals_status_idx on public.usdt_withdrawals (status);

create table if not exists public.direct_orders (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(user_id),
  product_id bigint references public.products(id),
  quantity integer default 1,
  bonus_quantity integer default 0,
  unit_price bigint,
  amount bigint,
  code text,
  status text default 'pending',
  created_at timestamptz
);
create index if not exists direct_orders_status_idx on public.direct_orders (status);
create index if not exists direct_orders_code_idx on public.direct_orders (code);

-- Backward-compatible column migrations
alter table public.products add column if not exists price_tiers jsonb;
alter table public.products add column if not exists promo_buy_quantity integer default 0;
alter table public.products add column if not exists promo_bonus_quantity integer default 0;
alter table public.products add column if not exists website_name text;
alter table public.products add column if not exists website_price bigint;
alter table public.products add column if not exists website_price_tiers jsonb;
alter table public.products add column if not exists website_promo_buy_quantity integer default 0;
alter table public.products add column if not exists website_promo_bonus_quantity integer default 0;
alter table public.products add column if not exists website_banner_url text;
alter table public.products add column if not exists website_logo_url text;
alter table public.products add column if not exists website_enabled boolean default true;
alter table public.direct_orders add column if not exists bonus_quantity integer default 0;

create table if not exists public.processed_transactions (
  tx_id text primary key,
  processed_at timestamptz default now()
);

-- Telegram chat logs (for admin dashboard 1-1 chat/history)
create table if not exists public.telegram_messages (
  id bigint generated by default as identity primary key,
  chat_id bigint not null,
  message_id bigint not null,
  direction text not null check (direction in ('in', 'out')),
  message_type text not null default 'text',
  text text,
  payload jsonb,
  sent_at timestamptz not null,
  created_at timestamptz default now()
);
create unique index if not exists telegram_messages_chat_message_idx on public.telegram_messages (chat_id, message_id);
create index if not exists telegram_messages_chat_sent_idx on public.telegram_messages (chat_id, sent_at desc);

-- Admin roles
do $$
begin
  if not exists (select 1 from pg_type where typname = 'admin_role') then
    create type public.admin_role as enum ('superadmin', 'admin');
  end if;
end $$;

create table if not exists public.admin_users (
  user_id uuid primary key references auth.users(id) on delete cascade,
  role public.admin_role not null default 'admin',
  created_at timestamptz default now()
);

-- Helper functions
create or replace function public.is_admin()
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists (
    select 1 from public.admin_users
    where user_id = auth.uid()
  );
$$;

create or replace function public.is_superadmin()
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists (
    select 1 from public.admin_users
    where user_id = auth.uid() and role = 'superadmin'
  );
$$;

create or replace function public.get_stats()
returns table (users bigint, orders bigint, revenue bigint)
language sql
stable
as $$
  select
    (select count(*) from public.users) as users,
    (select count(*) from public.orders) as orders,
    (select coalesce(sum(price), 0) from public.orders) as revenue;
$$;

create or replace function public.reset_sequences()
returns void
language plpgsql
security definer
as $$
begin
  perform setval(pg_get_serial_sequence('public.products', 'id'), coalesce((select max(id) from public.products), 1), true);
  perform setval(pg_get_serial_sequence('public.stock', 'id'), coalesce((select max(id) from public.stock), 1), true);
  perform setval(pg_get_serial_sequence('public.orders', 'id'), coalesce((select max(id) from public.orders), 1), true);
  perform setval(pg_get_serial_sequence('public.deposits', 'id'), coalesce((select max(id) from public.deposits), 1), true);
  perform setval(pg_get_serial_sequence('public.withdrawals', 'id'), coalesce((select max(id) from public.withdrawals), 1), true);
  perform setval(pg_get_serial_sequence('public.binance_deposits', 'id'), coalesce((select max(id) from public.binance_deposits), 1), true);
  perform setval(pg_get_serial_sequence('public.usdt_withdrawals', 'id'), coalesce((select max(id) from public.usdt_withdrawals), 1), true);
  perform setval(pg_get_serial_sequence('public.format_templates', 'id'), coalesce((select max(id) from public.format_templates), 1), true);
end $$;

-- Fast product queries with stock counts
drop function if exists public.get_products_with_stock();
create or replace function public.get_products_with_stock()
returns table (
  id bigint,
  name text,
  price bigint,
  price_usdt numeric,
  price_tiers jsonb,
  promo_buy_quantity integer,
  promo_bonus_quantity integer,
  website_name text,
  website_price bigint,
  website_price_tiers jsonb,
  website_promo_buy_quantity integer,
  website_promo_bonus_quantity integer,
  website_banner_url text,
  website_logo_url text,
  website_enabled boolean,
  description text,
  format_data text,
  stock bigint
)
language sql
stable
security definer
set search_path = public
as $$
  select
    p.id,
    p.name,
    p.price,
    p.price_usdt,
    p.price_tiers,
    p.promo_buy_quantity,
    p.promo_bonus_quantity,
    p.website_name,
    p.website_price,
    p.website_price_tiers,
    p.website_promo_buy_quantity,
    p.website_promo_bonus_quantity,
    p.website_banner_url,
    p.website_logo_url,
    p.website_enabled,
    p.description,
    p.format_data,
    coalesce(s.stock, 0) as stock
  from public.products p
  left join (
    select product_id, count(*) as stock
    from public.stock
    where sold = false
    group by product_id
  ) s on s.product_id = p.id
  where (auth.role() = 'service_role' or public.is_admin())
  order by p.id;
$$;

drop function if exists public.get_product_with_stock(bigint);
create or replace function public.get_product_with_stock(p_id bigint)
returns table (
  id bigint,
  name text,
  price bigint,
  price_usdt numeric,
  price_tiers jsonb,
  promo_buy_quantity integer,
  promo_bonus_quantity integer,
  website_name text,
  website_price bigint,
  website_price_tiers jsonb,
  website_promo_buy_quantity integer,
  website_promo_bonus_quantity integer,
  website_banner_url text,
  website_logo_url text,
  website_enabled boolean,
  description text,
  format_data text,
  stock bigint
)
language sql
stable
security definer
set search_path = public
as $$
  select
    p.id,
    p.name,
    p.price,
    p.price_usdt,
    p.price_tiers,
    p.promo_buy_quantity,
    p.promo_bonus_quantity,
    p.website_name,
    p.website_price,
    p.website_price_tiers,
    p.website_promo_buy_quantity,
    p.website_promo_bonus_quantity,
    p.website_banner_url,
    p.website_logo_url,
    p.website_enabled,
    p.description,
    p.format_data,
    coalesce(s.stock, 0) as stock
  from public.products p
  left join (
    select product_id, count(*) as stock
    from public.stock
    where sold = false
    group by product_id
  ) s on s.product_id = p.id
  where (auth.role() = 'service_role' or public.is_admin())
    and p.id = p_id
  limit 1;
$$;

-- Create deposit + return bank settings in one round-trip
create or replace function public.create_deposit_and_get_bank_settings(
  p_user_id bigint,
  p_amount bigint,
  p_code text
)
returns table (
  bank_name text,
  account_number text,
  account_name text
)
language plpgsql
security definer
set search_path = public
as $$
begin
  if not (auth.role() = 'service_role' or public.is_admin()) then
    raise exception 'not authorized';
  end if;

  insert into public.deposits (user_id, amount, code, created_at)
  values (p_user_id, p_amount, p_code, now());

  return query
  select
    max(value) filter (where key = 'bank_name') as bank_name,
    max(value) filter (where key = 'account_number') as account_number,
    max(value) filter (where key = 'account_name') as account_name
  from public.settings;
end $$;

-- Create direct order + return bank settings in one round-trip
create or replace function public.create_direct_order_and_get_bank_settings(
  p_user_id bigint,
  p_product_id bigint,
  p_quantity integer,
  p_bonus_quantity integer,
  p_unit_price bigint,
  p_amount bigint,
  p_code text
)
returns table (
  bank_name text,
  account_number text,
  account_name text
)
language plpgsql
security definer
set search_path = public
as $$
begin
  if not (auth.role() = 'service_role' or public.is_admin()) then
    raise exception 'not authorized';
  end if;

  insert into public.direct_orders (user_id, product_id, quantity, bonus_quantity, unit_price, amount, code, created_at)
  values (p_user_id, p_product_id, p_quantity, p_bonus_quantity, p_unit_price, p_amount, p_code, now());

  return query
  select
    max(value) filter (where key = 'bank_name') as bank_name,
    max(value) filter (where key = 'account_number') as account_number,
    max(value) filter (where key = 'account_name') as account_name
  from public.settings;
end $$;

-- RLS
alter table public.admin_users enable row level security;
-- NOTE: Keep admin_users policies non-recursive to avoid stack depth errors.
create policy "Admin can read own" on public.admin_users
  for select using (auth.uid() = user_id);

alter table public.users enable row level security;
create policy "Admins can access users" on public.users
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.products enable row level security;
create policy "Admins can access products" on public.products
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.stock enable row level security;
create policy "Admins can access stock" on public.stock
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.orders enable row level security;
create policy "Admins can access orders" on public.orders
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.deposits enable row level security;
create policy "Admins can access deposits" on public.deposits
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.withdrawals enable row level security;
create policy "Admins can access withdrawals" on public.withdrawals
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.settings enable row level security;
create policy "Admins can access settings" on public.settings
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.format_templates enable row level security;
create policy "Admins can read format templates" on public.format_templates
  for select using (public.is_admin());
create policy "Superadmins can write format templates" on public.format_templates
  for all using (public.is_superadmin()) with check (public.is_superadmin());

alter table public.binance_deposits enable row level security;
create policy "Admins can access binance deposits" on public.binance_deposits
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.usdt_withdrawals enable row level security;
create policy "Admins can access usdt withdrawals" on public.usdt_withdrawals
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.processed_transactions enable row level security;
create policy "Admins can access processed transactions" on public.processed_transactions
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.direct_orders enable row level security;
create policy "Admins can access direct orders" on public.direct_orders
  for all using (public.is_admin()) with check (public.is_admin());

alter table public.telegram_messages enable row level security;
create policy "Admins can access telegram messages" on public.telegram_messages
  for all using (public.is_admin()) with check (public.is_admin());

-- Storage bucket for admin uploads
insert into storage.buckets (id, name, public)
values ('admin-uploads', 'admin-uploads', false)
on conflict (id) do nothing;

-- NOTE: storage.objects is managed by Supabase; RLS is already enabled.
-- Do not alter storage.objects here to avoid permission errors.
create policy "Admins can access admin uploads" on storage.objects
  for all
  using (bucket_id = 'admin-uploads' and public.is_admin())
  with check (bucket_id = 'admin-uploads' and public.is_admin());
